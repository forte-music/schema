# An album is a collection of songs which belong to an artist and has a name.
type Album {
  # A globally unique id referring to this album.
  id: ID!

  # The http/https url at which a square PNG of the album artwork can be found.
  # Clients should request artwork with the same authentication as used with the
  # API server.
  artworkUrl: String

  # The human readable name of the album.
  name: String!

  # The artist who released the album. If there are multiple artists on the
  # album this is usually various artists (a designated id). This is usually the
  # album artists tag of files.
  album: Artist!

  # Songs in this album sorted by song index.
  songs: [Song!]!
}

# An artist has a name and albums.
type Artist {
  # A globally unique id referring to this artist.
  id: ID!

  # The human readable name of this artist.
  name: String!

  # Albums this artist has authored. These are the albums that this artist is
  # the album artist of.
  albums: [Album!]!

  # The albums which this artist has featured on. These are albums which the
  # artist isn't an album artist of but albums which the artist is in.
  featured: [Album!]!

  # Albums with only a single song where this artist is the album artist or an
  # artist of the song.
  singles: [Album!]!
}

# A song is a piece of music written by artists. It is always part of an album.
# It represents a singe audio file.
type Song {
  # A globally unique UUID referring to this song.
  id: ID!

  # The url at which the song can be streamed from. See
  # github.com/forte-music/schema for details about this field.
  streamUrl: String!

  # The track number of this song. This may be one or zero indexed and is
  # provided by the file's metadata.
  trackNumber: Int!

  # The disk this track is on. The disk number is assumed to be one if not
  # provided.
  diskNumber: Int!

  # The human readable name of this song.
  name: String!

  # The album this song is a part of. A song can only belong to one album.
  album: Album!

  # The artists which composed this song.
  artists: [Artist!]!

  # User stats for a song.
  stats: SongUserStats!
}

# Stats for a song tied to a specific user.
type SongUserStats {
  # A globally unique UUID referring to a song's stats.
  id: ID!

  # The number of times this song has been played.
  playCount: Int!

  # The epoch time (seconds) at which this song was last played.
  lastPlayed: Int!

  # Whether or not this song is favorited. Favorited songs go into their own
  # playlist.
  liked: Boolean!
}

# A named collection of songs. The same song can appear multiple times in a
# playlist.
type Playlist {
  # A globally unique UUID referring to this playlist.
  id: ID!

  # Human readable name of the playlist. This is chosen by the user when the
  # playlist is created.
  name: String!

  # An ordered list of songs in the playlist.
  songs(
    limit: Int = 25,

    # Cursor (SongEdge.cursor) from which to return elements from. If this
    # isn't specified, starts from the first position.
    cursor: String
  ): SongConnection!
}

# The connection and edge types below are used to implement pagination. The
# pattern is described here: http://graphql.org/learn/pagination/
#
# Cursors are opaque tokens which are bound to a query and can be used to
# request more items for a query (arguments and field combination).

type AlbumEdge {
  cursor: String!
  node: Album!
}

type AlbumConnection {
  count: Int!
  edges: [AlbumEdge!]!
}

type ArtistEdge {
  cursor: String!
  node: Artist!
}

type ArtistConnection {
  count: Int!
  edges: [ArtistEdge!]!
}

type SongEdge {
  cursor: String!
  node: Song!
}

type SongConnection {
  count: Int!
  edges: [SongEdge!]!
}

enum SortBy {
  # Sort from most recently added to least recently added.
  RECENTLY_ADDED,

  # Sort from most recently played to least recently played.
  RECENTLY_PLAYED,

  # Sort from most played to least played.
  MOST_PLAYED
}

type Query {
  # Get an album by its globally unique id.
  album(id: ID!): Album!

  # Get paginated, sorted albums.
  albums(
    limit: Int = 25,
    sortBy: SortBy = RECENTLY_ADDED,
    reverse: Boolean = false,

    # Cursor (AlbumEdge.cursor) from which to return elements from. If this
    # isn't specified, starts from the first position.
    cursor: String
  ): AlbumConnection!

  # Search only for albums by name.
  searchAlbums(
    name: String!,
    limit: Int = 25,

    # Cursor (AlbumEdge.cursor) from which to return elements from. If this
    # isn't specified, starts from the first position.
    cursor: String
  ): AlbumConnection!

  # Get an artist by its globally unique id.
  artist(id: ID!): Artist!

  # Get paginated, sorted artists.
  artists(
    limit: Int = 25,
    sortBy: SortBy = RECENTLY_ADDED,
    reverse: Boolean = false,

    # Cursor (ArtistEdge.cursor) from which to return elements from. If this
    # isn't specified, starts from the first position.
    cursor: String
  ): ArtistConnection!

  # Search only for artists by name.
  searchArtist(
    name: String!,
    limit: Int = 25,

    # Cursor (ArtistEdge.cursor) from which to return elements from. If this
    # isn't specified, starts from the first position.
    cursor: String
  ): ArtistConnection!

  # Get a song by its globally unique id.
  song(id: ID!): Song!

  # Get paginated, sorted songs.
  songs(
    limit: Int!,
    sortBy: SortBy = RECENTLY_ADDED,
    reverse: Boolean = false,

    # Cursor (SongEdge.cursor) from which to return elements from. If this isn't
    # specified, starts from the first position.
    cursor: String
  ): SongConnection!

  # Search only for songs by keyword.
  searchSongs(
    name: String!,
    limit: Int!,

    # Cursor (SongEdge.cursor) from which to return elements from. If this isn't
    # specified, starts from the first position.
    cursor: String
  ): SongConnection!

  # Get a playlist by its globally unique id.
  playlist(id: ID!): Playlist!

  # Get a sorted list of playlists.
  playlists(
    sortBy: SortBy = RECENTLY_ADDED,
    reverse: Boolean = false
  ): [Playlist!]!
}

enum Position {
  # Elements are inserted before the beginning of the list.
  BEGINNING,

  # Elements are inserted after the end of the list.
  END,
}

enum Offset {
  AFTER,
  BEFORE,
}

input PlaylistAppendInput {
  # The id of the playlist to add songs to.
  playlistId: ID!

  # The ids (Song.id) of songs to add to the playlist in the order specified.
  songs: [ID!]!
}

type Mutation {
  # Increments the play count and updates the last played time in SongUserStats.
  # Always returns true.
  playSong(songId: ID!): Boolean!

  # Toggles the like state of the specified song. Returns whether or not the
  # song is liked after the like is toggled.
  toggleLike(songId: ID!): Boolean!

  # Creates a new playlist. Returns the newly created playlist.
  createPlaylist(
    # The name of the new playlist.
    name: String!,

    # The ids of songs to add to the playlist in the order specified.
    songs: [ID!],
  ): Playlist!

  # Renames a playlist. Returns a playlist with the changes applied.
  updatePlaylist(
    # The id of the playlist to rename.
    playlistId: ID!,

    # The new name of the playlist.
    name: String!,
  ): Playlist!


  # Adds songs to the end or the beginning of a playlist.
  addToPlaylistRelative(
    input: PlaylistAppendInput!,
    position: Position!,
  ): Playlist!

  # Adds songs to a playlist relative to a cursor (Playlist.songs.edges.cursor).
  # This is useful because in some cases the index isn't known and is not and is
  # hard to compute because of its dependence on global state while cursors are
  # local state.
  addToPlaylistByCursor(
    input: PlaylistAppendInput!,

    # The cursor relative to which to add songs (Playlist.songs.edges.cursor).
    cursor: String!,

    # The direction relative to the cursor where songs will be added.
    offset: Offset!,
  ): Playlist!

  # Adds songs to a playlist relative to an index.
  addToPlaylistByIndex(
    input: PlaylistAppendInput!,

    # The zero indexed offset relative to which to add songs.
    position: Int!,

    # The direction relative to the offset where songs will be added.
    offset: Offset!,
  ): Playlist!

  # Remove songs from the playlist. Returns the updated playlist.
  removeFromPlaylist(
    # The playlist to remove items from.
    playlistId: ID!,

    # A list of cursors from Playlist.songs.edges.cursor pointing to songs to
    # remove from the playlist.
    songs: [String!]!,
  ): Playlist!

  # Permanently deletes a playlist.
  deletePlaylist(
    # The id of the playlist to delete.
    playlistId: ID!
  ): Boolean!
}

schema {
  query: Query
  mutation: Mutation
}
