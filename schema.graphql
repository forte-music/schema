# An album is a collection of songs which belong to an artist and has a name.
type Album {
  # A globally unique id referring to this album.
  id: ID!

  # The http/https url at which a square PNG of the album artwork can be found.
  # Clients should request artwork with the same authentication as used with the
  # API server.
  artworkUrl: String

  # The human readable name of the album.
  name: String!

  # The artist who released the album. If there are multiple artists on the
  # album this is usually various artists (a designated id). This is usually the
  # album artists tag of files.
  artist: Artist!

  # Songs in this album sorted by song index.
  songs: [Song!]!

  # The sum of the durations of every song in this album album in seconds.
  duration: Int!

  # The year the album was released.
  releaseYear: Int!
}

# An artist has a name and albums.
type Artist {
  # A globally unique id referring to this artist.
  id: ID!

  # The human readable name of this artist.
  name: String!

  # Albums this artist has authored. These are the albums that this artist is
  # the album artist of. The albums are sorted by release date.
  albums: [Album!]!

  # Get all songs of an artist.
  songs(
    input: ConnectionQuery
  ): SongConnection!
}

# A song is a piece of music written by artists. It is always part of an album.
# It represents a singe audio file.
type Song {
  # A globally unique id referring to this song.
  id: ID!

  # The url at which the song can be streamed from. See
  # github.com/forte-music/schema for details about this field.
  streamUrl: String!

  # The track number of this song. This may be one or zero indexed and is
  # provided by the file's metadata.
  trackNumber: Int!

  # The disk this track is on. The disk number is assumed to be one if not
  # provided.
  diskNumber: Int!

  # The human readable name of this song.
  name: String!

  # The album this song is a part of. A song can only belong to one album.
  album: Album!

  # The artists which composed this song. This includes the album artist.
  artists: [Artist!]!

  # User stats for a song.
  stats: SongUserStats!

  # The duration of the file (retrievable at streamUrl) in seconds.
  duration: Int!
}

# Stats for a song tied to a specific user.
type SongUserStats {
  # A globally unique id referring to a song's stats.
  id: ID!

  # The number of times this song has been played.
  playCount: Int!

  # The epoch time (seconds) at which this song was last played.
  lastPlayed: Int!

  # Whether or not this song is liked. Liked songs go into their own
  # auto-playlist.
  liked: Boolean!
}

# An item in a playlist.
type PlaylistItem {
  # The id of the playlist item. This is position invariant and allows for
  # addressing items in a playlist.
  id: ID!

  # The song this item points to.
  song: Song!
}

# A named collection of songs. The same song can appear multiple times in a
# playlist.
type Playlist {
  # A globally unique id referring to this playlist.
  id: ID!

  # Human readable name of the playlist. This is chosen by the user when the
  # playlist is created.
  name: String!

  # The sum of durations of every song in the playlist in seconds.
  duration: Int!

  # The items in the playlist.
  items(
    input: ConnectionQuery,
  ): PlaylistItemConnection!
}

# The connection and edge types below are used to implement pagination. The
# pattern is described here: http://graphql.org/learn/pagination/
#
# Cursors are opaque tokens which are bound to a query and can be used to
# request more items for a query (arguments and field combination). Cursors
# are tied to a view of the data. If new data is added continuted pagination
# returns the old data.
type AlbumEdge {
  cursor: String!
  node: Album!
}

type AlbumConnection {
  count: Int!
  edges: [AlbumEdge!]!
}

type ArtistEdge {
  cursor: String!
  node: Artist!
}

type ArtistConnection {
  count: Int!
  edges: [ArtistEdge!]!
}

type SongEdge {
  cursor: String!
  node: Song!
}

type SongConnection {
  count: Int!
  edges: [SongEdge!]!
}

type PlaylistEdge {
  cursor: String!
  node: Playlist!
}

type PlaylistConnection {
  count: Int!
  edges: [PlaylistEdge!]!
}

type PlaylistItemEdge {
  cursor: String!
  node: PlaylistItem!
}

type PlaylistItemConnection {
  count: Int!
  edges: [PlaylistItemEdge!]!
}

enum SortBy {
  # Sort from most recently added to least recently added.
  RECENTLY_ADDED,

  # Sort from most recently played to least recently played.
  RECENTLY_PLAYED,

  # Sort from most played to least played.
  MOST_PLAYED,

  # Sort by title in case-insensitive alphabetic order.
  LEXICOGRAPHICALLY,
}

input ConnectionQuery {
  # The maximum number of results to return.
  limit: Int = 25,

  # The order in which the results are sorted in. By default they are sorted
  # from most recently added to least recently added, unless otherwise
  # specified.
  sortBy: SortBy,

  # Returns the results sorted in reverse order.
  reverse: Boolean = false,

  # Results after this cursor (Edge.cursor) will be returned. If not specified,
  # starts from the first position.
  cursor: String = "",

  # Only results with titles matching this string are returned. If this is
  # specified, the default sortBy will now be from best match to worst match.
  filter: String = "",
}

type Query {
  # Get an album by its globally unique id.
  album(id: ID!): Album!

  # Get paginated, filtered, sorted albums.
  albums(
    input: ConnectionQuery,
  ): AlbumConnection!

  # Get an artist by its globally unique id.
  artist(id: ID!): Artist!

  # Get paginated, filtered, sorted artists.
  artists(
    input: ConnectionQuery,
  ): ArtistConnection!

  # Get a song by its globally unique id.
  song(id: ID!): Song!

  # Get paginated, filtered, sorted songs.
  songs(
    input: ConnectionQuery,
  ): SongConnection!

  # Get a playlist by its globally unique id.
  playlist(id: ID!): Playlist!

  # Get a sorted list of playlists.
  playlists(
    input: ConnectionQuery,
  ): PlaylistConnection!
}

enum Position {
  # Elements are inserted before the beginning of the list.
  BEGINNING,

  # Elements are inserted after the end of the list.
  END,
}

enum Offset {
  AFTER,
  BEFORE,
}

input PlaylistAppendInput {
  # The id of the playlist to add songs to.
  playlistId: ID!

  # The ids (Song.id) of songs to add to the playlist in the order specified.
  songs: [ID!]!
}

type Mutation {
  # Increments the play count and updates the last played time in SongUserStats.
  # Always returns true.
  playSong(songId: ID!): Boolean!

  # Toggles the like state of the specified song. Returns whether or not the
  # song is liked after the like is toggled.
  toggleLike(songId: ID!): Boolean!

  # Creates a new playlist. Returns the newly created playlist.
  createPlaylist(
    # The name of the new playlist.
    name: String!,

    # The ids of songs to add to the playlist in the order specified. If an
    # invalid id is passed, the entire request fails.
    songs: [ID!],
  ): Playlist!

  # Renames a playlist. Returns a playlist with the changes applied.
  updatePlaylist(
    # The id of the playlist to rename.
    playlistId: ID!,

    # The new name of the playlist.
    name: String!,
  ): Playlist!

  # Adds songs to the end or the beginning of a playlist.
  addToPlaylistRelative(
    input: PlaylistAppendInput!,
    position: Position!,
  ): Playlist!

  # Adds songs to a playlist relative to an item (PlaylistItem.id). This is
  # useful because in some cases the index isn't known and is not and is hard to
  # compute because of its dependence on global state while ids are local state.
  addToPlaylistByCursor(
    input: PlaylistAppendInput!,

    # The id of the item relative to which to add songs (PlaylistItem.id).
    relativeTo: ID!

    # The direction relative to the item specified by relativeTo where songs
    # will be added.
    offset: Offset!,
  ): Playlist!

  # Adds songs to a playlist relative to an index.
  addToPlaylistByIndex(
    input: PlaylistAppendInput!,

    # The zero indexed offset relative to which to add songs.
    position: Int!,

    # The direction relative to the offset where songs will be added.
    offset: Offset!,
  ): Playlist!

  # Remove songs from the playlist. Returns the updated playlist.
  removeFromPlaylist(
    # The playlist to remove items from.
    playlistId: ID!,

    # A list of ids from PlaylistItem.id for items to remove from the playlist.
    items: [ID!]!,
  ): Playlist!

  # Permanently deletes a playlist.
  deletePlaylist(
    # The id of the playlist to delete.
    playlistId: ID!
  ): Boolean!

  # Moves a song in a playlist from one position to another.
  moveSongInPlaylist(
    # The id of the playlist to modify.
    playlistId: ID!,

    # The id (PlaylistItem.id) of the element to move.
    fromItem: ID!,

    # The id of the item fromItem will be moved relative to.
    relativeToItem: ID!,

    # The direction relative to relativetoItem the item pointed to by fromItem
    # will be moved to.
    offset: Offset!
  ): Playlist!
}

schema {
  query: Query
  mutation: Mutation
}
